package controller;

import java.awt.Component;
import java.awt.Cursor;

import javax.swing.JOptionPane;

import model.QubicBoard;
import model.Square;
import view.View;
import view.View3D;

/**
 * This is the final class in the inheritance chain of controllers, so it is
 * the one instantiated by the QubicMain class. It defines the public method
 * start which begins a new game, as well as other private methods used in
 * reacting to various events generated by clicks and game state (such as game over).
 * @author Blake Thomson
 */
public final class GameController2 extends InputController {	
	private boolean clickOkay;
	private int delay;
	private Square s2;
	
	/**
	 * Calls the super-class constructor.
	 * @param b
	 */
	public GameController2(QubicBoard b) {
		super(b);
		delay = 1000;
	}
	
	/**
	 * The only public method of the controller. It initializes the GUI and causes the computer
	 * to play if the board reports that it is the first player.
	 */
	public void start() {
		getFrame().setVisible(true);
		clickOkay = true;
		if (getFirstPlayer() != null) {
			((Component) getFrame()).setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
			Thread t = new Thread (new Runnable() {
				public void run() {
					s2 = getFirstPlayer().go(QubicBoard.Player.FIRST);
				}
			});
			
			t.start();
			try { 
				Thread.sleep(delay);
				t.join();
			} catch (InterruptedException e) {
				System.out.println(e);
			}
			computerMove(s2);
			((Component) getFrame()).setCursor(null);
		}
	}
		
	/**
	 * Where most of the gameplay happens. It checks to see if it is okay to click, 
	 * then moves the human to the Square s (given as a parameter). If the human
	 * successfully moves to the selected square, it checks for game over, and if the
	 * human has not won, the computer plays. Finally, it checks again for game over.
	 */
	@Override
	void humanMove(Square s) {		
		if (!clickOkay)
			return;
		handleMove(s);
		clickOkay = false;
		handleNextMove();
	}
	
	/**
	 * The code that makes the computer move. It, unlike humanMove, is not dependent
	 * on clickOkay at all.
	 * @param s
	 */
	void computerMove(Square s) {
		handleMove(s);
		handleNextMove();
	}
	
	/**
	 * In humanMove or computerMove, after a single move is handled, this method
	 * is called to check if the other player is a computer. If it is, it is asked
	 * to play, and the cycle continues again.
	 */
	void handleNextMove() {
		if (!handleGameOver()) {
			if (getBoard().getCurrentPlayer() == QubicBoard.Player.FIRST) {
				if (getFirstPlayer() != null) {
					((Component) getFrame()).setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
					Thread t = new Thread (new Runnable() {
						public void run() {
							s2 = getFirstPlayer().go(QubicBoard.Player.FIRST);
						}
					});
					
					t.start();
					try { 
						Thread.sleep(delay);
						t.join();
					} catch (InterruptedException e) {
						System.out.println(e);
					}
					computerMove(s2);
					((Component) getFrame()).setCursor(null);
				} else
					clickOkay = true;
			} else {
				if (getSecondPlayer() != null) {
					((Component) getFrame()).setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
					Thread t = new Thread (new Runnable() {
						public void run() {
							s2 = getSecondPlayer().go(QubicBoard.Player.SECOND);
						}
					});
					
					t.start();
					try { 
						Thread.sleep(delay);
						t.join();
					} catch (InterruptedException e) {
						System.out.println(e);
					}
					computerMove(s2);
					((Component) getFrame()).setCursor(null);
				} else
					clickOkay = true;
			}
		}
	}
	
	/**
	 * Handles just one move, no matter it's origin. Tells the board to select
	 * the given square, then depending on whether that was successful, enables/disables
	 * various things, and writes a line to the history panel. Calls handleGameOver at
	 * the end, and sets clickOkay to be opposite of what that returns.
	 * @param s
	 */
	void handleMove(Square s) {
		getUndoAction().setEnabled(false);
		boolean success = getBoard().select(s);
		if (success) {
			getHistoryPanel().writeLine();
			getUndoAction().setEnabled(true);
			getSaveAction().setEnabled(true);
		}
	}	
	
	/**
	 * It checks that state of the QubicBoard, and if the board says that the game is 
	 * over or it is a cats game, it displays a dialog asking the user whether they want 
	 * to play again or not.
	 * @return A boolean indicating whether the game is over or not, (as decided by
	 * the QubicBoard object itself).
	 */
	boolean handleGameOver() {
		if (getBoard().catsGame() || getBoard().gameOver()) {
			clickOkay = false;
			String message;
			if (getBoard().catsGame())
				message = "It's a cat's game!";
			else {
				message = "The game is over... ";
				if (getBoard().getLastMove().getState() == QubicBoard.Player.FIRST) {
					message += "and the first player won!";
				} else {
					message += "and the second player won!";
				}					
			}
			((View) getMainView()).clearHighlight();
			((View3D) get3DView()).clearHighlight();
			int result = JOptionPane.showConfirmDialog(getFrame(),
					message + "\nDo you want to play again?",
					"Start New Game?", JOptionPane.YES_NO_OPTION);
			if (result == JOptionPane.YES_OPTION)
				handleNewGame();
			return true;
		} else
			return false;
	}
	
	/**
	 * Called by the handleGameOver method and used in the new game action object
	 * to handle the details of starting a new game. It resets the board, and
	 * calls start() to begin another game.
	 */
	@Override
	void handleNewGame() {
		getBoard().resetBoard();
		getHistoryPanel().clearHistory();
		start();
	}
	
	/**
	 * Called by the options dialog to set the time duration to wait before the computer moves.
	 * @param d The number of milliseconds the computer must wait before it moves.
	 */
	@Override
	void setDelay(int d) {
		delay = d;
	}
	
	/**
	 * Used to update the number in the options dialog indicating how long the wait time is.
	 */
	@Override
	int getDelay() {
		return delay;
	}
}