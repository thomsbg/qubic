package controller;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import javax.swing.JOptionPane;
import javax.swing.SwingWorker;

import model.QubicBoard;
import model.Square;

/**
 * This is the final class in the inheritance chain of controllers, so it is
 * the one instantiated by the QubicMain class. It defines the public method
 * start which begins a new game, as well as other private methods used in
 * reacting to various events generated by clicks and game state (such as game over).
 * @author Blake
 */
public final class GameController extends ViewController {	
	private Task task;
	private boolean clickOkay;
	
	/**
	 * Calls the super-class constructor.
	 * @param b
	 */
	public GameController(QubicBoard b) {
		super(b);
		clickOkay = true;
	}
	
	/**
	 * The only public method of the controller. It initializes the GUI and causes the computer
	 * to play if the board reports that it is the first player.
	 */
	public void start() {
		getFrame().setVisible(true);
		if (getBoard().getFirstPlayer() == QubicBoard.Player.COMPUTER) {
			clickOkay = false;
			task = new Task();
			task.addPropertyChangeListener(new ProgressBarListener());
			task.execute();
		}
	}
	
	/**
	 * Where most of the gameplay happens. It checks to see if it is okay to click, 
	 * then moves the human to the Square s (given as a parameter). If the human
	 * successfully moves to the selected square, it checks for game over, and if the
	 * human has not won, the computer plays. Finally, it checks again for game over.
	 */
	@Override
	void handleMoves(Square s) {
		if (!clickOkay)
			return;
		clickOkay = false;
		getUndoAction().setEnabled(false);
		boolean success = getBoard().select(s);		
		if (success) {
			getHistoryPanel().humanMoves(s);
			if (!handleGameOver()) {
				task = new Task();
				task.addPropertyChangeListener(new ProgressBarListener());
				task.execute();
			}
		} else
			clickOkay = true;	
	}
	
	/**
	 * A private method that is called after the human plays, and again after
	 * the computer plays. It checks that state of the QubicBoard, and if the
	 * board says that the game is over or it is a cats game, it displays a dialog
	 * asking the user whether they want to play again or not.
	 * @return A boolean indicating whether the game is over or not, (as decided by
	 * the QubicBoard object itself).
	 */
	boolean handleGameOver() {
		if (getBoard().catsGame() || getBoard().gameOver()) {
			clickOkay = false;
			String message;
			if (getBoard().catsGame())
				message = "It's a cat's game!";
			else {
				message = "The game is over... ";
				if (getBoard().getCurrentPlayer() == QubicBoard.Player.COMPUTER)
					message += "and you won! I can't believe it...";
				else
					message += "and you lost. Sorry about that mate.";
			}
			int result = JOptionPane.showConfirmDialog(getFrame(),
					message + "\nDo you want to play again?",
					"Start New Game?", JOptionPane.YES_NO_OPTION);
			if (result == JOptionPane.YES_OPTION)
				handleNewGame();
			return true;
		} else
			return false;
	}
	
	/**
	 * Called by the handleGameOver method and used in the new game action object
	 * to handle the details of starting a new game. It resets the board, and
	 * calls start() to begin another game.
	 */
	@Override
	void handleNewGame() {
		getBoard().resetBoard();
		getHistoryPanel().clearHistory();
		System.out.println(getBoard());
		System.out.println("-----------------------------------------");
		start();
	}
	
	/**
	 * The helper method used by the undo action object to update the
	 * history panel by removing the last line of output. It is called twice
	 * by the undo action object, so two lines are removed when undo is pressed.
	 */
	@Override
	void handleUndo() {
		getHistoryPanel().undoMove();
	}
	
	/**
	 * The helper method used by the open action object to assign the board field
	 * to a new QubicBoard read in from a file.
	 */
	@Override
	void handleNewBoard(QubicBoard b) {
		setBoard(b);
		getBoard().addListener(getMainView());
		getBoard().addListener(get3DView());
		getBoard().addListener(getHistoryPanel());
	}
	
	/**
	 * A class implementing the PropertyChangeListener interface to be used with
	 * the "Task" object also defined in GameController. These two classes together
	 * provide the progress bar functionality, showing how much time left the computer
	 * has to think.
	 */
	class ProgressBarListener implements PropertyChangeListener {
		public void propertyChange(PropertyChangeEvent evt) {
			if ("progress" == evt.getPropertyName()) {
	            int progress = (Integer) evt.getNewValue();
	            getProgressBar().setValue(progress);
			}
		}
	}
	
	/**
	 * The Task class defines a thread to run in the background, waiting 2
	 * seconds before the computer moves. It updates its progress every 20 ms, 
	 * thereby allowing the ProgressBarListener to follow it, and display how
	 * a meter showing how much time is left to wait before the computer plays.
	 */
	class Task extends SwingWorker<Void, Void> {
		public Void doInBackground() {
			int progress = 100;
            setProgress(100);
            while (progress > 0) {
                try {
                    Thread.sleep(20);
                } catch (InterruptedException ignore) {
                	throw new RuntimeException(ignore.toString());
                }
                progress -= 1;
                setProgress(Math.max(progress, 0));
            }
            return null;
		}
		
		public void done() {
			handleComputerMove();
		}
	}
	
	/**
	 * A private method called by the inner class "Task". It asks the currentAi
	 * object for its next move, and then moves there. It also updates the history panel
	 * status, and toggles the visibility of various buttons/menu items.
	 */
	void handleComputerMove() {
		Square s = getCurrentAi().go();
		getBoard().select(s);
		getHistoryPanel().computerMoves(s);
		getUndoAction().setEnabled(true);
		getSaveAction().setEnabled(true);
		clickOkay = !handleGameOver();
	}
}
