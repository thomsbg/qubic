package controller;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JOptionPane;
import javax.swing.Timer;

import model.QubicBoard;
import model.Square;

/**
 * This is the final class in the inheritance chain of controllers, so it is
 * the one instantiated by the QubicMain class. It defines the public method
 * start which begins a new game, as well as other private methods used in
 * reacting to various events generated by clicks and game state (such as game over).
 * @author Blake
 */
public final class GameController extends ViewController {	
	private boolean clickOkay;
	
	/**
	 * Calls the super-class constructor.
	 * @param b
	 */
	public GameController(QubicBoard b) {
		super(b);
		clickOkay = true;
	}
	
	/**
	 * The only public method of the controller. It initializes the GUI and causes the computer
	 * to play if the board reports that it is the first player.
	 */
	public void start() {
		getFrame().setVisible(true);
		if (getBoard().getFirstPlayer() == QubicBoard.Player.COMPUTER) {
			computerMove(getBoard().getFirstAI().go());
		}
	}
		
	/**
	 * Where most of the gameplay happens. It checks to see if it is okay to click, 
	 * then moves the human to the Square s (given as a parameter). If the human
	 * successfully moves to the selected square, it checks for game over, and if the
	 * human has not won, the computer plays. Finally, it checks again for game over.
	 */
	@Override
	void handleMoves(Square s) {
		if (!clickOkay)
			return;
		handleMove(s);
		clickOkay = false;
		if (getBoard().getCurrentPlayer() == getBoard().getFirstPlayer()) {
			if (getBoard().getFirstPlayer() == QubicBoard.Player.COMPUTER) {
				Square s2 = getBoard().getFirstAI().go();
				computerMove(s2);
			} else
				clickOkay = true;
		} else {
			if (getBoard().getSecondPlayer() == QubicBoard.Player.COMPUTER) {
				Square s2 = getBoard().getSecondAI().go();
				computerMove(s2);
			} else
				clickOkay = true;
		}
	}
	
	void handleMove(Square s) {
		getUndoAction().setEnabled(false);
		boolean success = getBoard().select(s);		
		if (success) {
			getHistoryPanel().writeLine();
			getUndoAction().setEnabled(true);
			getSaveAction().setEnabled(true);
		}
		clickOkay = !handleGameOver();
	}
	
	void computerMove(Square s) {
		final Square sFinal = s;
		getProgressBar().setValue(0);
		final Timer t = new Timer(100, null);
		t.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				getProgressBar().setValue(getProgressBar().getValue() + 10);
				if (getProgressBar().getValue() == 100) {
					t.stop();
					handleMove(sFinal);
				}
			}
		});
		t.start();
	}
	
	/**
	 * A private method that is called after the human plays, and again after
	 * the computer plays. It checks that state of the QubicBoard, and if the
	 * board says that the game is over or it is a cats game, it displays a dialog
	 * asking the user whether they want to play again or not.
	 * @return A boolean indicating whether the game is over or not, (as decided by
	 * the QubicBoard object itself).
	 */
	boolean handleGameOver() {
		if (getBoard().catsGame() || getBoard().gameOver()) {
			clickOkay = false;
			String message;
			if (getBoard().catsGame())
				message = "It's a cat's game!";
			else {
				message = "The game is over... ";
				if (getBoard().getLastMove().getState() == QubicBoard.Player.HUMAN)
					message += "and you won! I can't believe it...";
				else
					message += "and the computer won!";
			}
			int result = JOptionPane.showConfirmDialog(getFrame(),
					message + "\nDo you want to play again?",
					"Start New Game?", JOptionPane.YES_NO_OPTION);
			if (result == JOptionPane.YES_OPTION)
				handleNewGame();
			return true;
		} else
			return false;
	}
	
	/**
	 * Called by the handleGameOver method and used in the new game action object
	 * to handle the details of starting a new game. It resets the board, and
	 * calls start() to begin another game.
	 */
	@Override
	void handleNewGame() {
		getBoard().resetBoard();
		getHistoryPanel().clearHistory();
		start();
	}
	
	/**
	 * The helper method used by the undo action object to update the
	 * history panel by removing the last line of output. It is called twice
	 * by the undo action object, so two lines are removed when undo is pressed.
	 */
	@Override
	void handleUndo() {
		getHistoryPanel().removeLine();
		clickOkay = true;
	}
	
	/**
	 * The helper method used by the open action object to assign the board field
	 * to a new QubicBoard read in from a file.
	 */
	@Override
	void handleNewBoard(QubicBoard b) {
		setBoard(b);
		getBoard().addListener(getMainView());
		getBoard().addListener(get3DView());
		getBoard().addListener(getHistoryPanel());
	}
}
